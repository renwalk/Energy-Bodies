<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Energy Bodies — Display</title>

  <!-- silence favicon 404 -->
  <link rel="icon" href="data:,">

  <!-- p5 FIRST -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>

  <!-- REMOVE p5.sound for now; add later only if needed -->

  <!-- ml5 AFTER p5 (CDN, not local) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ml5/0.12.2/ml5.min.js"></script>

  <!-- your sketch LAST -->
  <script defer src="./sketch.js"></script>

  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>

<body>
<script>
let socket;

window.addEventListener('load', () => {
  console.log("✅ display.html loaded, starting WebSocket...");

// Get current hostname from the page URL (works for both laptop + iPad)
const host = window.location.hostname;

// Connect to WebSocket server on same host at port 8080
socket = new WebSocket(`ws://${host}:8080`);



  socket.onopen = () => {
    console.log("✅ CONNECTED to WebSocket server");
  };

  socket.onerror = (err) => {
    console.error("❌ WebSocket error:", err);
  };

  socket.onmessage = (event) => {
    // If Blob → convert to string
    if (event.data instanceof Blob) {
      const reader = new FileReader();
      reader.onload = () => {
        handleIncomingMessage(reader.result);
      };
      reader.readAsText(event.data);
    } else {
      handleIncomingMessage(event.data);
    }
  };

  function handleIncomingMessage(message) {
    let data;
    try {
      data = JSON.parse(message);
    } catch (err) {
      console.warn("❌ Invalid JSON from WebSocket:", message);
      return;
    }

    // ✅ Update emotion sliders in memory
    if (data.emotion && window.emotionSliders) {
      for (let name in data.emotion) {
        if (window.emotionSliders[name] && typeof window.emotionSliders[name].value === "function") {
          window.emotionSliders[name].value(data.emotion[name]);
        }
      }
    }

    // ✅ Update region sliders in memory
    if (data.region && window.regionSliders) {
      for (let name in data.region) {
        if (window.regionSliders[name] && typeof window.regionSliders[name].value === "function") {
          window.regionSliders[name].value(data.region[name]);
        }
      }
    }

    // ✅ Handle start/stop tracking
    if (data.action === "start" && typeof window.startTracking === "function") {
      window.startTracking();
    }
    if (data.action === "stop" && typeof window.stopTracking === "function") {
      window.stopTracking();
    }
  }
});
</script>
</body>
</html>
