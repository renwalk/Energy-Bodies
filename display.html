<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Energy Bodies — Display</title>
  <link rel="icon" href="data:,">

  <!-- Local libs (blocking) -->
  <script src="./p5.min.js"></script>
  <script src="./ml5.min.js"></script>

  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
    canvas { display:block; }
    /* Orientation helper (if you want to react in CSS; JS event is also dispatched) */
    .portrait body, body.portrait { transform-origin: center center; }
  </style>
</head>
<body>

<script>
// =====================================================
// Energy Bodies — Display Receiver (no HUD)
// Bridges WS messages from Control → sketch.js and lets
// sketch.js emit back (pose/tracking/echo). No DOM UI.
// =====================================================
(function(){
  // Exposed helpers your sketch.js can call
  const Emitter = {
    socket: null,
    pose(obj){ safeSend({ type:'pose', ...obj }); },
    tracking(on){ safeSend({ type:'tracking', on: !!on }); },
    echo(state){
      const payload = { type:'echo' };
      if (state?.emotion) payload.emotion = state.emotion;
      if (state?.region)  payload.region  = state.region;
      safeSend(payload);
    }
  };
  window.EnergyBodiesDisplay = Emitter;

  // Orientation handling → dispatch event for sketch.js
  function applyOrientation(value){
    const cls = value === 'portrait' ? 'portrait' : 'landscape';
    document.body.classList.toggle('portrait', cls === 'portrait');
    window.dispatchEvent(new CustomEvent('eb:orientation', { detail:{ value:cls } }));
  }

  // WebSocket with auto-retry
  let socket; let retry = 800; const MAX = 8000;
  function wsUrl(port=8080){
    const proto = location.protocol==='https:' ? 'wss' : 'ws';
    return `${proto}://${location.hostname}:${port}`;
  }
  function connect(){
    try { socket = new WebSocket(wsUrl(8080)); } catch (e) { return setTimeout(connect, retry); }
    Emitter.socket = socket;

    socket.onopen  = () => { retry = 800; };
    socket.onclose = () => { setTimeout(connect, Math.min(MAX, (retry *= 1.6))); };
    socket.onerror = () => {};
    socket.onmessage = (event) => {
      const handle = (txt)=>{ let msg; try{ msg = JSON.parse(txt);}catch{ return; } route(msg); };
      if (event.data instanceof Blob){ const r=new FileReader(); r.onload=()=>handle(r.result); r.readAsText(event.data); }
      else handle(String(event.data));
    };
  }
  connect();

  function safeSend(obj){
    if (Emitter.socket && Emitter.socket.readyState === WebSocket.OPEN) {
      try { Emitter.socket.send(JSON.stringify(obj)); } catch {}
    }
  }

  // Route control messages → sketch.js
  function route(payload){
    const { type } = payload || {};
    if (!type) return;

    if (type === 'sliders'){
      if (typeof window.applySliders === 'function') {
        window.applySliders(payload.emotion||{}, payload.region||{});
      }
      return;
    }

    if (type === 'action'){
      if (payload.action === 'start' && typeof window.startTracking === 'function'){
        window.startTracking();
        Emitter.tracking(true);
      }
      if (payload.action === 'stop' && typeof window.stopTracking === 'function'){
        window.stopTracking();
        Emitter.tracking(false);
      }
      return;
    }

    if (type === 'orientation'){
      applyOrientation(payload.value);
      return;
    }

    if (type === 'print'){
      // Trigger the renderer’s print routine (no on-screen button)
      if (typeof window.onPrintClick === 'function') {
        window.onPrintClick();
      }
      return;
    }
  }

  // Announce initial state (optional)
  Emitter.tracking(false);
})();
</script>

<!-- Your renderer LAST so it can see EnergyBodiesDisplay -->
<script defer src="./sketch.js"></script>
</body>
</html>
