<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <!-- Removed Google Fonts to avoid external fetch -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Energy Bodies—-Control</title>
  <!-- Removed CDN p5 script; not used in this file and blocks offline -->
  <style>
    /* === Title Font: Gimlet Sans Display Light === */
    @font-face {
      font-family: "Gimlet Sans Display";
      src: url("./fonts/GimletSansDisplay-Light.otf") format("opentype");
      font-weight: 300;
      font-style: normal;
      font-display: swap;
    }

    /* === Body Text Font: Gimlet Sans Text Light === */
    @font-face {
      font-family: "Gimlet Sans Text";
      src: url("./fonts/GimletSansText-Light.otf") format("opentype");
      font-weight: 300;
      font-style: normal;
      font-display: swap;
    }

    */ :root {
      color-scheme: dark;
      /* type tokens */
      /* Body copy / labels / sliders */
      --font-sans: "Gimlet Sans Text", ui-sans-serif, system-ui, -apple-system, sans-serif;
      /* Title font */
      --font-display: "Gimlet Sans Display", ui-sans-serif, system-ui, -apple-system, sans-serif;
      --fs-xs: 12px;
      --fs-sm: 13px;
      --fs-md: 14px;
      --fs-lg: 18px;
      --fs-xl: clamp(16px, 2.2vw, 20px);
      --lh-tight: 1.2;
      --lh-normal: 1.5;
      --gap: 12px;
      --radius: 14px;
      --panel-bg: #0b0b0b;
      --panel-bd: #1a1a1a;
      --track: #2a2a2a;
      --pill-bg: #1d1d1d;
      --header-h: 64px;
      --label-w: 40px;
      --value-w: 40px;
      --thumb: 22px;
      /* button sizing (independent from slider --thumb) */
      --control-h: 44px;
      /* target min tap size on iPad */
      --btn-px: 12px;
      /* horizontal padding */
      --btn-py: 10px;
      /* vertical padding (used if taller than min) */
      --btn-radius: 12px;
      /* button corner radius */
    }

    html,
    body {
      margin: 0;
      background: #000;
      color: #ddd;
      font-family: var(--font-sans);
      font-size: var(--fs-md);
      line-height: var(--lh-normal);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: linear-gradient(#000, rgba(0, 0, 0, 0.82));
      border-bottom: 1px solid #222;
    }

    .header-inner {
      height: var(--header-h);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 12px;
      text-transform: uppercase;
    }

    .title {
      font-family: var(--font-display);
      font-size: var(--fs-xl);
      font-weight: 300;
      letter-spacing: .02em;
    }

    .hdr-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pill {
      font-family: var(--font-sans);
      font-size: var(--fs-xs);
      font-weight: 300;
      letter-spacing: .02em;
      background: transparent;
      border: 1px solid transparent;
      color: #bbb;
    }

    .ok,
    .warn,
    .err {
      background: transparent !important;
      border-color: transparent !important;
      color: #bbb !important;
    }

    .wrap {
      display: grid;
      gap: var(--gap);
      padding: var(--gap);
      max-width: 1600px;
      margin: 0 auto;
      grid-auto-rows: minmax(0, auto);
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-template-areas:
        "intro    regions"
        "controls regions"
        "emotions feedback"
        "feedback feedback";
    }

    @media (min-width: 1000px) {
      .wrap {
        grid-template-columns: repeat(4, minmax(0, 1fr));
        grid-template-areas:
          "intro    regions emotions feedback"
          "controls regions emotions feedback";
      }
    }

    @media (min-width: 1366px) {
      .wrap {
        grid-template-columns: repeat(5, minmax(0, 1fr));
        grid-template-areas:
          "intro    regions emotions feedback feedback"
          "intro regions controls  feedback feedback";
      }
    }

    .panel {
      background: var(--panel-bg);
      border: 1px solid var(--panel-bd);
      border-radius: var(--radius);
      padding: 12px;
      min-height: 120px;
      max-height: calc(100vh - var(--header-h) - (var(--gap) * 2));
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    .panel h3 {
      font-size: var(--fs-lg);
      font-weight: 600;
      line-height: var(--lh-tight);
      margin: 0 0 6px;
    }

    .panel p {
      margin: 6px 0 0;
      opacity: .9;
    }

    /* Enhanced welcome panel as hero card */
    #welcomeCard.panel {
      max-width: 520px;
      margin: 0 auto;
      padding: 24px 22px;
    }

    #welcomeCard h3 {
      font-family: var(--font-display);
      font-size: 24px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    #welcomeCard .intro-tagline {
      font-size: var(--fs-md);
      margin-top: 10px;
      margin-bottom: 14px;
    }

    .is-hidden {
      display: none;
    }

    #welcomeCard {
      grid-area: intro;
    }

    #intro {
      grid-area: intro;
    }

    #regions {
      grid-area: regions;
    }

    #emotions {
      grid-area: emotions;
    }

    #controls {
      grid-area: controls;
    }

    #feedback {
      grid-area: feedback;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: auto auto;
      row-gap: 6px;
      background: #111;
      border: 1px solid #1c1c1c;
      padding: 8px 10px;
      border-radius: 10px;
    }

    .row-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .row label {
      font-size: var(--fs-sm);
      font-weight: 400;
    }

    .row label.label-with-dot {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-transform: capitalize;
    }

    .row label.label-with-dot .legend-dot {
      margin-top: 0;
    }

    .row .val,
    .mval {
      font-size: var(--fs-xs);
    }

    .row input[type="range"] {
      width: 100%;
      min-width: 0;
      appearance: none;
      height: 20px;
      background: transparent;
    }

    input[type="range"] {
      height: 32px;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 8px;
      background: var(--track);
      border-radius: 999px;
    }

    :root {
      --thumb: 20px;
    }

    input[type="range"]::-webkit-slider-thumb {
      width: var(--thumb);
      height: var(--thumb);
      margin-top: calc((8px - var(--thumb)) / 2);
      border-radius: 50%;
      background: #757677;
      border: 0;
    }

    /* Buttons */
    .btns {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    button,
    .seg>button {
      min-height: var(--control-h);
      padding: 0 var(--btn-px);
      font-size: var(--fs-sm);
      font-weight: 600;
      border-radius: var(--btn-radius);
      -webkit-appearance: none;
      appearance: none;
      -webkit-tap-highlight-color: transparent;
      line-height: 1;
      width: 100%;
      background: #1a1a1a;
      color: #ddd;
      border: 1px solid #2a2a2a;
    }

    .primary-btn {
      margin-top: 8px;
    }

    .seg {
      display: inline-flex;
      overflow: hidden;
      border-radius: var(--btn-radius);
    }

    .seg>button {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 var(--btn-px);
    }

    .seg>button.is-active {
      background: #223;
      color: #9ad;
    }

    .metrics {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .metric h4 {
      margin: 0 0 6px;
      font-size: 12px;
      color: #ccc;
      opacity: .9;
      font-weight: 600;
      letter-spacing: .2px;
    }

    .bar {
      height: 8px;
      background: #222;
      border-radius: 999px;
      overflow: hidden;
    }

    .bar>i {
      display: block;
      height: 100%;
      width: 0%;
      background: #9ad;
    }

    .mval {
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-size: 12px;
      opacity: .9;
      margin-top: 4px;
    }

    #skeletonCard {
      padding: 8px;
    }

    #skeletonCard h4 {
      margin-bottom: 8px;
    }

    #skelCanvas {
      width: 100%;
      height: 260px;
      display: block;
      background: #000;
      border-radius: 8px;
      border: 1px solid #1c1c1c;
    }

    @media (min-width: 1000px) {
      #skelCanvas {
        height: 300px;
      }
    }

    #wsPill,
    #echoPill {
      display: none;
    }

    /* Intro panel text tweaks */
    .intro-tagline {
      margin: 4px 0 10px;
      font-size: var(--fs-sm);
      opacity: 0.9;
    }

    .intro-steps {
      margin: 0 0 12px;
      padding-left: 18px;
      font-size: var(--fs-sm);
    }

    .intro-steps li {
      margin-bottom: 6px;
    }

    .intro-note {
      margin-top: 8px;
      font-size: var(--fs-xs);
      opacity: 0.75;
    }

    body.welcome header {
      display: none;
    }

    body.welcome .wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      max-width: 640px;
      padding: 24px 16px;
    }

    /* Welcome is just text on the background, not a card */
    body.welcome #welcomeCard {
      max-height: none;
      width: 100%;
      text-align: center;
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
    }

    body.welcome #welcomeCard h3 {
      text-align: center;
    }

    body.welcome #welcomeCard .intro-steps {
      text-align: left;
    }

    body.welcome #welcomeCard .intro-note {
      text-align: center;
    }

    .secondary-btn {
      margin-top: 10px;
      font-weight: 500;
      opacity: 0.9;
    }

    .legend-box {
      margin-top: 8px;
      margin-bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #252525;
      background: #101010;
      font-size: var(--fs-xs);
    }

    .legend-box h4 {
      margin: 0 0 6px;
      font-size: var(--fs-sm);
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      opacity: 0.9;
    }

    .legend-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 4px;
    }

    .legend-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
    }

    .legend-dot {
      flex-shrink: 0;
      width: 18px;
      height: 12px;
      border-radius: 3px;
      /* slightly rounded rectangle */
      margin-top: 2px;
      background: #666;
      border: 1px solid #222;
    }

    /* Anxiety: dense, overlapping short lines */
    .dot-anxiety {
      background:
        repeating-linear-gradient(25deg,
          #f0f0f0 0px,
          #f0f0f0 2px,
          transparent 2px,
          transparent 4px),
        repeating-linear-gradient(-30deg,
          #bcbcbc 0px,
          #bcbcbc 2px,
          transparent 2px,
          transparent 5px),
        repeating-linear-gradient(70deg,
          #6b6b6b 0px,
          #6b6b6b 1px,
          transparent 1px,
          transparent 3px);
      background-color: #222222;
    }

    /* Sadness: blue tint / cool palette */
    .dot-sadness {
      background: linear-gradient(90deg, #1c3a63 0%, #2e6cb0 50%, #75b5ff 100%);
    }

    /* Joy: bright yellow / radiant */
    .dot-joy {
      background: linear-gradient(90deg, #ffea7a 0%, #ffd94c 50%, #ffb800 100%);
    }

    /* Anger: hot pink / magenta, sharper intensity */
    .dot-anger {
      background:
        repeating-linear-gradient(135deg,
          #ff9acb 0px,
          #ff9acb 2px,
          #ff4fa6 2px,
          #ff4fa6 4px);
    }

    /* Fear: jagged edges, unsettled grayscale */
    .dot-fear {
      background:
        repeating-linear-gradient(135deg,
          #f5f5f5 0px,
          #f5f5f5 2px,
          #000000 2px,
          #000000 3px);
      background-color: #000000;
      border-color: #f0f0f0;
      box-shadow:
        0 0 3px rgba(255, 255, 255, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.4);
      clip-path: polygon(0% 18%, 8% 0%, 22% 22%, 35% 5%,
          50% 25%, 63% 3%, 78% 20%, 100% 5%,
          100% 82%, 90% 100%, 75% 78%, 60% 95%,
          45% 72%, 30% 100%, 15% 80%, 0% 100%);
    }

    /* Calm: thin, smooth curved lines, grayscale */
    .dot-calm {
      background:
        repeating-radial-gradient(circle at 0 120%,
          #000000 0px,
          #000000 1px,
          transparent 1px,
          transparent 6px),
        repeating-radial-gradient(circle at 18px -40%,
          #000000 0px,
          #000000 1px,
          transparent 1px,
          transparent 6px);
      background-color: #f5f5f5;
      border-color: #3a3a3a;
      box-shadow: inset 0 0 2px rgba(255, 255, 255, 0.5);
    }

    .legend-label {
      font-weight: 500;
      text-transform: capitalize;
      margin-right: 2px;
    }

    .legend-desc {
      opacity: 0.9;
    }
  </style>
</head>

<body class="welcome">
  <header>
    <div class="header-inner">
      <div class="title">Energy Bodies</div>
      <div class="hdr-right">
        <span id="wsPill" class="pill">WS: …</span>
        <span id="echoPill" class="pill">Echo: —</span>
        <span id="trkPill" class="pill">Tracking: OFF</span>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- Welcome card shown in "welcome" mode -->
    <section id="welcomeCard" class="panel">
      <h3>Energy Bodies</h3>
      <p class="intro-tagline">
        Energy Bodies is an interactive installation that translates movement and emotional inputs into a living visual
        form.
      </p>
      <p>
        Your gestures will be translated into color and motion, creating a living image of your “energy body.”
      </p>

      <button id="beginSessionBtn" class="primary-btn">Begin Session</button>
      <p class="intro-note">
        Participants can move as much or as little as feels comfortable and can step away at any time.
        No identifiable personal data is stored.
      </p>
    </section>

    <!-- Session Guide panel shown alongside controls once a session has begun -->
    <section id="intro" class="panel is-hidden">
      <h3>Session Guide</h3>
      <p class="intro-tagline">
        <strong>Scan your body</strong>—take a moment to notice sensations from head to toe: areas of ease, tension,
        warmth, or pain.
        <strong>your emotions</strong>—are you calm, anxious, joyful, or something else?
      </p>
      <p> Use the sliders to reflect what you feel: left for little or no sensation/emotion, right for strong or
        intense internal feelings. Press <strong>Start </strong> to move within the frame—your gestures become streams
        of color and
        line. Press <strong>Print</strong> to take home your image of embodied energy.
      </p>
    </section>

    <!-- These panels are hidden until Begin Session is tapped -->
    <section id="regions" class="panel is-hidden">
      <h3>Region Inputs</h3>
      <div id="regionGrid" class="grid"></div>
    </section>

    <section id="emotions" class="panel is-hidden">
      <h3>Emotion Inputs</h3>
      <div id="emotionGrid" class="grid"></div>
    </section>

    <section id="controls" class="panel is-hidden">
      <h3>Controls</h3>
      <div class="btns">
        <button id="startBtn">Start</button>
        <button id="stopBtn">Stop</button>
        <button id="resetBtn">Reset</button>
        <button id="printBtn" disabled>Print</button>
      </div>
      <button id="endSessionBtn" class="secondary-btn">End Session &amp; Return to Welcome</button>
    </section>

    <section id="feedback" class="panel is-hidden">
      <h3>Live Feedback</h3>
      <div class="metrics" id="metrics"></div>
      <div class="metric" id="skeletonCard">
        <h4>Live Skeleton</h4>
        <canvas id="skelCanvas"></canvas>
      </div>
    </section>
  </main>

  <script>
    // =============================
    // Config & Schema
    // =============================
    const EMOTIONS = ["anxiety", "sadness", "joy", "anger", "fear", "calm"];
    const EMOTION_DOT_CLASS = {
      anxiety: 'dot-anxiety',
      sadness: 'dot-sadness',
      joy: 'dot-joy',
      anger: 'dot-anger',
      fear: 'dot-fear',
      calm: 'dot-calm'
    };

    const REGIONS = ["head", "neck", "armsHands", "chest", "abdomen", "legsFeet", "spine"];
    const SPINE = "spine";
    const WS_PORT = 8080;

    let socket = null; let retryMs = 800; let sendTimer = null;
    const wsPill = document.getElementById('wsPill');
    const trkPill = document.getElementById('trkPill');
    const echoPill = document.getElementById('echoPill');

    function setPill(el, txt, cls) { if (!el) return; el.textContent = txt; el.className = `pill ${cls || ''}`; }

    // Use host of the page (works since iPad loads from Mac mini URL)
    function wsUrl(port = WS_PORT) {
      const host = new URL(location.href).hostname; // becomes 192.168.0.102 on iPad
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      return `${proto}://${host}:${port}`;
    }

    function connectWS() {
      try { socket = new WebSocket(wsUrl()); }
      catch (e) { setPill(wsPill, 'WS: error', 'err'); return setTimeout(connectWS, retryMs); }
      socket.onopen = () => { setPill(wsPill, 'WS: open', 'ok'); retryMs = 800; };
      socket.onclose = () => { setPill(wsPill, 'WS: closed', 'warn'); setTimeout(connectWS, Math.min(8000, retryMs *= 1.6)); };
      socket.onerror = () => { setPill(wsPill, 'WS: error', 'err'); };
      socket.onmessage = (evt) => {
        let msg; try { msg = JSON.parse(typeof evt.data === 'string' ? evt.data : (new TextDecoder().decode(evt.data))); } catch { return; }
        if (!msg || !msg.type) return;
        if (msg.type === 'tracking') setTrackingState(!!msg.on);
        else if (msg.type === 'pose') { updateMetrics(msg); if (msg.keypoints) { latestPose = msg; requestAnimationFrame(drawSkeleton); } }
        else if (msg.type === 'echo') applyEcho(msg);
      };
    }
    console.log('[WS] trying', wsUrl());
    connectWS();

    // =============================
    // UI Build
    // =============================
    const emotionGrid = document.getElementById('emotionGrid');
    const regionGrid = document.getElementById('regionGrid');
    const sliders = {};

    function makeRow(name, min, max, step) {
      const row = document.createElement('div'); row.className = 'row';
      const top = document.createElement('div'); top.className = 'row-top';

      const label = document.createElement('label');
      label.setAttribute('for', `sl-${name}`);

      // If this is an emotion slider, show a color/pattern chip
      if (EMOTION_DOT_CLASS[name]) {
        label.classList.add('label-with-dot');
        const chip = document.createElement('span');
        chip.className = 'legend-dot ' + EMOTION_DOT_CLASS[name];
        const textSpan = document.createElement('span');
        textSpan.textContent = name;
        label.append(chip, textSpan);
      } else {
        // For regions / other sliders, keep simple label text
        label.textContent = name;
      }

      const val = document.createElement('div'); val.className = 'val'; val.textContent = '0.0';
      top.append(label, val);

      const input = document.createElement('input'); input.id = `sl-${name}`; input.type = 'range'; input.min = String(min); input.max = String(max); input.step = String(step); input.value = '0';
      input.addEventListener('input', () => { val.textContent = Number(input.value).toFixed((step < 1) ? 1 : 0); sendValuesThrottled(); });
      row.append(top, input); sliders[name] = input; return row;
    }

    EMOTIONS.forEach(n => emotionGrid.appendChild(makeRow(n, 0, 5, 0.1)));
    REGIONS.forEach(n => regionGrid.appendChild(n === SPINE ? makeRow(n, 0, 100, 1) : makeRow(n, 0, 5, 0.1)));

    // Buttons
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const printBtn = document.getElementById('printBtn');

    startBtn.addEventListener('click', () => { sendAction('start'); setTrackingState(true); });
    stopBtn.addEventListener('click', () => { sendAction('stop'); setTrackingState(false); });
    resetBtn.addEventListener('click', () => {
      Object.entries(sliders).forEach(([name, inp]) => {
        inp.value = 0; const vEl = inp.parentElement.querySelector('.val');
        if (vEl) vEl.textContent = (name === 'spine') ? '0' : '0.0';
      });
      setTrackingState(false); clearFeedback(); sendAction('reset');
    });

    // Averaging / Print
    let isAveraging = false; let avgTimer = null; const AVG_MS = 2500;
    printBtn.addEventListener('click', onPrintButton);
    function onPrintButton() {
      if (!isAveraging) {
        isAveraging = true; printBtn.textContent = 'Averaging… tap to print';
        safeSend({ type: 'startTracking' }); safeSend({ type: 'beginSession' });
        avgTimer = setTimeout(() => { safeSend({ type: 'print' }); isAveraging = false; printBtn.textContent = 'Print Avg'; }, AVG_MS);
      } else {
        if (avgTimer) clearTimeout(avgTimer);
        safeSend({ type: 'print' }); isAveraging = false; printBtn.textContent = 'Print Avg';
      }
    }

    // Orientation segmented buttons (if present)
    const seg = document.querySelectorAll('.seg > button');
    seg.forEach(btn => btn.addEventListener('click', () => {
      seg.forEach(b => b.classList.remove('is-active')); btn.classList.add('is-active'); sendOrientation(btn.dataset.orient);
    }));

    function setTrackingState(on) {
      setPill(trkPill, `Tracking: ${on ? 'ON' : 'OFF'}`, on ? 'ok' : '');
      if (printBtn) printBtn.disabled = !on;
      if (!on) clearFeedback();
    }

    // =============================
    // Messaging
    // =============================
    function safeSend(obj) { if (socket && socket.readyState === WebSocket.OPEN) { socket.send(JSON.stringify(obj)); } }
    function collectValues() {
      const emotion = {}, region = {};
      EMOTIONS.forEach(n => emotion[n] = Number(sliders[n].value));
      REGIONS.forEach(n => region[n] = Number(sliders[n].value));
      return { emotion, region };
    }
    function sendValues() { safeSend({ type: 'sliders', ...collectValues() }); setPill(echoPill, 'Echo: sent', ''); }
    function sendValuesThrottled() { if (__applyingEcho) return; if (sendTimer) return; sendTimer = setTimeout(() => { sendTimer = null; sendValues(); }, 60); }
    function sendAction(action) { safeSend({ type: 'action', action }); }
    function sendOrientation(value) { safeSend({ type: 'orientation', value }); }

    // =============================
    // Live metrics (from Display)
    // =============================
    const METRIC_KEYS = [['movementVelocity', 0, 1], ['fastVel', 0, 1], ['structure', 0, 1], ['balance', 0, 1], ['postureLean', 0, 1], ['avgY', 0, 1]];
    let latestPose = null;
    const EDGES = [
      ['leftShoulder', 'rightShoulder'],
      ['leftHip', 'rightHip'],
      ['leftShoulder', 'leftHip'],
      ['rightShoulder', 'rightHip'],
      ['leftShoulder', 'leftElbow'],
      ['leftElbow', 'leftWrist'],
      ['rightShoulder', 'rightElbow'],
      ['rightElbow', 'rightWrist'],
      ['leftHip', 'leftKnee'],
      ['leftKnee', 'leftAnkle'],
      ['rightHip', 'rightKnee'],
      ['rightKnee', 'rightAnkle'],
      ['leftShoulder', 'nose'],
      ['rightShoulder', 'nose']
    ];
    const metricsEl = document.getElementById('metrics'); const meters = new Map();

    function mkMetric(name, min, max) {
      const el = document.createElement('div'); el.className = 'metric';
      const h = document.createElement('h4'); h.textContent = name;
      const bar = document.createElement('div'); bar.className = 'bar';
      const fill = document.createElement('i'); bar.appendChild(fill);
      const mval = document.createElement('div'); mval.className = 'mval'; mval.textContent = '—';
      el.append(h, bar, mval); metricsEl.appendChild(el); meters.set(name, { fill, mval, min, max });
    }
    METRIC_KEYS.forEach(([k, lo, hi]) => mkMetric(k, lo, hi));

    function updateMetrics(obj) {
      let any = false;
      METRIC_KEYS.forEach(([k, lo, hi]) => {
        if (typeof obj[k] !== 'number') return;
        any = true; const val = obj[k]; const m = meters.get(k);
        const pct = Math.max(0, Math.min(1, (val - m.min) / (m.max - m.min)));
        m.fill.style.width = `${Math.round(pct * 100)}%`; m.mval.textContent = String(val.toFixed(2));
      });
      if (any) setPill(echoPill, 'Echo: live', 'ok');
    }

    function drawSkeleton() {
      const cvs = document.getElementById('skelCanvas'); if (!cvs || !latestPose?.keypoints) return;
      const rect = cvs.getBoundingClientRect();
      if (cvs.width !== Math.floor(rect.width) || cvs.height !== Math.floor(rect.height)) { cvs.width = Math.floor(rect.width); cvs.height = Math.floor(rect.height); }
      const ctx = cvs.getContext('2d'); const W = cvs.width, H = cvs.height;
      ctx.clearRect(0, 0, W, H);
      const pts = new Map();
      latestPose.keypoints.forEach(([part, nx, ny, s]) => { pts.set(part, { x: nx * W, y: ny * H, s }); });
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(160,190,255,0.9)'; ctx.beginPath();
      EDGES.forEach(([a, b]) => {
        const pa = pts.get(a), pb = pts.get(b);
        if (!pa || !pb) return;
        if ((pa.s ?? 0) < 0.2 && (pb.s ?? 0) < 0.2) return;
        ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y);
      });
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      pts.forEach(p => {
        if ((p.s ?? 0) < 0.15) return;
        const r = 3 + 2 * Math.max(0, Math.min(1, p.s));
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI * 2); ctx.fill();
      });
    }

    function clearFeedback() {
      meters.forEach(m => { m.fill.style.width = '0%'; m.mval.textContent = '—'; });
      latestPose = null;
      const cvs = document.getElementById('skelCanvas');
      if (cvs) {
        const ctx = cvs.getContext('2d', { willReadFrequently: true });
        if (ctx) ctx.clearRect(0, 0, cvs.width, cvs.height);
      }
    }

    // =============================
    // Intro gating → reveal controls
    // =============================
    let __applyingEcho = false;
    function applyEcho(msg) {
      try {
        __applyingEcho = true;
        if (msg.emotion) Object.entries(msg.emotion).forEach(([k, v]) => {
          if (sliders[k]) {
            sliders[k].value = v;
            const vEl = sliders[k].parentElement.querySelector('.val');
            if (vEl) vEl.textContent = Number(v).toFixed(1);
          }
        });
        if (msg.region) Object.entries(msg.region).forEach(([k, v]) => {
          if (sliders[k]) {
            sliders[k].value = v;
            const vEl = sliders[k].parentElement.querySelector('.val');
            if (vEl) vEl.textContent = (k === 'spine') ? String(v | 0) : Number(v).toFixed(1);
          }
        });
      } finally { __applyingEcho = false; }
      setPill(echoPill, 'Echo: synced', 'ok');
    }

    // throttle sender: bail if echoing
    function sendValuesThrottled() {
      if (__applyingEcho) return;
      if (sendTimer) return;
      sendTimer = setTimeout(() => { sendTimer = null; sendValues(); }, 60);
    }

    window.addEventListener('DOMContentLoaded', () => {
      const welcomeCard = document.getElementById('welcomeCard');
      const introPanel = document.getElementById('intro');
      const beginBtn = document.getElementById('beginSessionBtn');
      const endSessionBtn = document.getElementById('endSessionBtn');
      const gatedIds = ['intro', 'regions', 'emotions', 'controls', 'feedback'];

      if (beginBtn) {
        beginBtn.addEventListener('click', () => {
          // Hide welcome card, show session panels
          welcomeCard?.classList.add('is-hidden');
          gatedIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.classList.remove('is-hidden');
          });
          // Switch from welcome layout back to grid layout
          document.body.classList.remove('welcome');
        });
      }

      if (endSessionBtn) {
        endSessionBtn.addEventListener('click', () => {
          // Stop tracking and clear visuals
          setTrackingState(false);
          clearFeedback();
          sendAction('stop');
          sendAction('reset');

          // Reset sliders to zero
          Object.entries(sliders).forEach(([name, inp]) => {
            inp.value = 0;
            const vEl = inp.parentElement.querySelector('.val');
            if (vEl) vEl.textContent = (name === 'spine') ? '0' : '0.0';
          });

          // Hide session panels, show welcome card again
          gatedIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.classList.add('is-hidden');
          });
          welcomeCard?.classList.remove('is-hidden');
          document.body.classList.add('welcome');
        });
      }
    });
  </script>
</body>

</html>